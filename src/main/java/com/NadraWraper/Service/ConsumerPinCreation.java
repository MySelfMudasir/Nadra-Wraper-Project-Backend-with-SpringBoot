package com.NadraWraper.Service;

import com.NadraWraper.Model.ApiResponse;
import com.NadraWraper.Model.DTO.UserRegistrationDto;
import com.NadraWraper.Model.entity.UserRegistration;
import com.NadraWraper.Model.entity.UserSchema;
import com.NadraWraper.Repository.UserRegistrationRepository;
import com.NadraWraper.Utility.AESEncryption;
import com.NadraWraper.Utility.AESKeyProvider;
import org.apache.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.security.SecureRandom;
import java.sql.Timestamp;
import java.time.Duration;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.temporal.Temporal;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import javax.crypto.SecretKey;
@Service
public class ConsumerPinCreation {
    @Autowired
    private UserRegistrationRepository userRegistrationRepository;
    @Autowired
    private AESEncryption aesEncryption;
    @Autowired
    private  AESKeyProvider aesKeyProvider;
    @Autowired
    private SmsSenderService smsSenderService;

@Value("${otp.validity.minutes}")
private double otpValidity;



private UserRegistration userRegistration;
    public String generatePin(int length) {
        SecureRandom random = new SecureRandom();
        StringBuilder pin = new StringBuilder();

        for (int i = 0; i < length; i++) {
            pin.append(random.nextInt(10)); // 0â€“9 digits
        }
        return pin.toString();
    }

    @Transactional
    public String saveAutoGeneratedPin(String cnic) {
        String generatedPin = generatePin(4);

        try {
            String encryptedPin = aesEncryption.encrypt(
                    generatedPin,
                    aesKeyProvider.getSecretKey(),
                    aesKeyProvider.getIv()
            );

                userRegistrationRepository.updateAllPinsByCnic(encryptedPin, cnic);

            return "PIN updated successfully for CNIC: " + cnic + ". Generated PIN: " + generatedPin;
        } catch (Exception e) {
            e.printStackTrace();
            return "Failed to update PIN: " + e.getMessage();
        }
    }



    public String getPin(String cnic) {
        try {
            String encryptedPin = userRegistrationRepository.findPinByCnic(cnic.toUpperCase());

            if (encryptedPin == null || encryptedPin.isEmpty()) {
                return "PIN is not set for this user or user not found.";
            }

            String decryptedPin = aesEncryption.decrypt(
                    encryptedPin,
                    aesKeyProvider.getSecretKey(),
                    aesKeyProvider.getIv()
            );

            // Return confirmation message (don't expose the PIN)
            return "PIN decrypted successfully. (Internal use only: " + decryptedPin + ")";

        } catch (Exception e) {
            e.printStackTrace(); // or use proper logging
            return "Error occurred while decrypting PIN: " + e.getMessage();
        }
    }

    public ApiResponse generateOTP(UserRegistrationDto userRegistrationDto) {
        ApiResponse apiResponse = new ApiResponse();

        try {
            String cnic = userRegistrationDto.getCnic();

            if (cnic != null && !cnic.isEmpty()) {
                UserSchema user = userRegistrationRepository.findByCnic(cnic); // Native query returns UserSchema

                if (user != null) {
                    String otp = generatePin(4); // Generate 6-digit OTP
                    String encryptedOtp = aesEncryption.encrypt(
                            otp,
                            aesKeyProvider.getSecretKey(),
                            aesKeyProvider.getIv()

                    );

                    user.setOtp(encryptedOtp);
                    System.out.println(user+"{}");
//                    user.setOtpGeneratedTime(LocalDateTime.now()); // Save generation time
                    user.setOtpGeneratedTime(new Timestamp((long) (System.currentTimeMillis() + (otpValidity * 60 * 1000))));

                    userRegistrationRepository.save(user); // Save OTP to DB
                    String message = "Your OTP is: " + otp + ". Please do not share this with anyone.";

                    smsSenderService.sendSms(user.getMobile() , message,"1");

                    log.info("Generated OTP: " + otp);
                    apiResponse.setResponseCode(ResponseCode.SUCCESS);
                    apiResponse.setResponseMessage("OTP generated and saved successfully");
                } else {
                    apiResponse.setResponseCode(ResponseCode.record_not_exist);
                    apiResponse.setResponseMessage("User record does not exist");
                }
            }

        } catch (Exception e) {
            apiResponse.setResponseCode(ResponseCode.FAILURE);
            apiResponse.setResponseMessage("Exception occurred while generating OTP: " + e.getMessage());
            e.printStackTrace();
        }

        return apiResponse;
    }

    public ApiResponse verifyOtp(String cnic, String inputOtp) throws Exception {
        ApiResponse response = new ApiResponse();

        UserSchema user = userRegistrationRepository.findByCnic(cnic);
        if (user == null) {
            response.setResponseCode(ResponseCode.record_not_exist);
            response.setResponseMessage("User not found.");
            return response;
        }

        if (user.getOtpGeneratedTime() == null || user.getOtp() == null) {
            response.setResponseCode(ResponseCode.FAILURE);
            response.setResponseMessage("No OTP generated.");
            return response;
        }

        Instant otpGeneratedTime = user.getOtpGeneratedTime().toInstant();
        Instant now = Instant.now();

        Duration duration = Duration.between(otpGeneratedTime, now);
        if (duration.toMinutes() >= 5) {
            response.setResponseCode(ResponseCode.FAILURE);
            response.setResponseMessage("OTP has expired.");
            return response;
        }

        String decryptedOtp = aesEncryption.decrypt(user.getOtp(), aesKeyProvider.getSecretKey(), aesKeyProvider.getIv());

        if (decryptedOtp.equals(inputOtp)) {
            response.setResponseCode(ResponseCode.SUCCESS);
            response.setResponseMessage("OTP verified successfully.");
        } else {
            response.setResponseCode(ResponseCode.FAILURE);
            response.setResponseMessage("Invalid OTP.");
        }

        return response;
    }


    private final static Logger log = Logger.getLogger(ConsumerPinCreation.class);



}
